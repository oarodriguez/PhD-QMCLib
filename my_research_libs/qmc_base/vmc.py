"""
    my_research_libs.qmc_base.vmc
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Contains the basic classes and routines used to estimate the ground
    state properties of a quantum gas using the Variational Monte Carlo (VMC)
    technique.
"""
import enum
import math
from abc import ABCMeta, abstractmethod
from collections import Iterable
from enum import Enum, IntEnum
from typing import Iterator, NamedTuple, Optional, Union

import numpy as np
from cached_property import cached_property
from numba import jit
from numpy import random as random

__all__ = [
    'CoreFuncs',
    'CoreFuncsMeta',
    'NormalSampling',
    'NTPFSpecNT',
    'RandDisplaceStat',
    'Sampling',
    'SpecNT',
    'StateNT',
    'StateProp',
    'StatesBatchNT',
    'NormalCoreFuncs',
    'UTPFSpecNT',
    'WFSpecNT',
    'rand_displace_normal',
    'rand_displace_uniform'
]


class PPFType(str, Enum):
    """The type of """
    UNIFORM = 'uniform'
    GAUSSIAN = 'gaussian'


PPF_UNIFORM = PPFType.UNIFORM
PPF_GAUSSIAN = PPFType.GAUSSIAN


class RandDisplaceStat(IntEnum):
    """"""
    REJECTED = 0
    ACCEPTED = 1


STAT_REJECTED = int(RandDisplaceStat.REJECTED)
STAT_ACCEPTED = int(RandDisplaceStat.ACCEPTED)


class WFSpecNT(NamedTuple):
    """The parameters of the trial wave function.

    We declare this class to help with typing and nothing more. A concrete
    spec should be implemented for every concrete model. It is recommended
    to inherit from this class to keep a logical sequence in the code.
    """
    pass


class NTPFSpecNT(NamedTuple):
    """The parameters of the transition probability function.

    The parameters correspond to a sampling done with random numbers
    generated from a normal (gaussian) distribution function.
    """
    #: The standard deviation of the normal distribution.
    sigma: float


class UTPFSpecNT(NamedTuple):
    """Parameters of the transition probability function.

    The parameters correspond to a sampling done with random numbers
    generated from a uniform distribution function.
    """
    move_spread: float


class SpecNT(NamedTuple):
    """The parameters to realize a sampling."""
    wf_spec: WFSpecNT
    tpf_spec: Union[NTPFSpecNT, UTPFSpecNT]
    ini_sys_conf: np.ndarray
    rng_seed: int


@enum.unique
class StateProp(str, enum.Enum):
    """The properties of a configuration."""
    WF_ABS_LOG = 'WF_ABS_LOG'
    MOVE_STAT = 'MOVE_STAT'


class StateNT(NamedTuple):
    """The data yielded at every iteration of the VMC generator object."""
    sys_conf: np.ndarray
    wf_abs_log: float
    move_stat: int


class StatesBatchNT(NamedTuple):
    """The data of the Markov chain generated by the sampling."""
    confs: np.ndarray
    props: np.ndarray
    accept_rate: float


class Sampling(Iterable, metaclass=ABCMeta):
    """Realizes a VMC sampling.

    Defines the parameters and methods to realize of a Variational Monte
    Carlo calculation. A uniform distribution is used to generate random
    numbers.
    """
    __slots__ = ()

    #: The spread magnitude of the random moves for the sampling.
    move_spread: float

    #: The initial configuration of the sampling.
    ini_sys_conf: np.ndarray

    #: The seed of the pseudo-RNG used to explore the configuration space.
    rng_seed: Optional[int]

    @property
    @abstractmethod
    def wf_spec_nt(self):
        """The parameters of the trial eave function."""
        pass

    @property
    @abstractmethod
    def tpf_spec_nt(self):
        """The parameters of the transition probability function."""
        pass

    @property
    def spec_nt(self):
        """The spec of the VMC sampling functions as a named tuple."""
        return SpecNT(self.wf_spec_nt,
                      self.tpf_spec_nt,
                      self.ini_sys_conf,
                      self.rng_seed)

    @property
    @abstractmethod
    def core_funcs(self) -> 'NormalCoreFuncs':
        """The core functions of the sampling."""
        pass

    def as_chain(self, num_steps: int):
        """Returns the VMC sampling as an array object.

        :param num_steps: The number of states to generate.
        """
        spec_nt = self.spec_nt
        return self.core_funcs.as_chain(spec_nt.wf_spec,
                                        spec_nt.tpf_spec,
                                        num_steps,
                                        spec_nt.ini_sys_conf,
                                        spec_nt.rng_seed)

    def __iter__(self) -> Iterator[StateNT]:
        """Iterable interface."""
        spec_nt = self.spec_nt
        return self.core_funcs.generator(spec_nt.wf_spec,
                                         spec_nt.tpf_spec,
                                         spec_nt.ini_sys_conf,
                                         spec_nt.rng_seed)


# Numpy dtype for the properties of a VMC sampling state.
states_props_dtype = np.dtype([
    (StateProp.WF_ABS_LOG.value, np.float64),
    (StateProp.MOVE_STAT.value, np.bool)
])


class NormalSampling(Iterable, metaclass=ABCMeta):
    """Realizes a VMC sampling.

    Defines the parameters and methods to realize of a Variational Monte
    Carlo calculation. A normal distribution is used to generate random
    numbers.
    """
    __slots__ = ()

    #: The "time-step" (squared, average move spread) of the sampling.
    time_step: float

    #: The initial configuration of the sampling.
    ini_sys_conf: np.ndarray

    #: The seed of the pseudo-RNG used to explore the configuration space.
    rng_seed: Optional[int]

    @property
    @abstractmethod
    def wf_spec_nt(self):
        """The parameters of the trial eave function."""
        pass

    @property
    @abstractmethod
    def tpf_spec_nt(self):
        """The parameters of the transition probability function."""
        pass

    @property
    def spec_nt(self):
        """The spec of the VMC sampling functions as a named tuple."""
        return SpecNT(self.wf_spec_nt,
                      self.tpf_spec_nt,
                      self.ini_sys_conf,
                      self.rng_seed)

    @property
    @abstractmethod
    def core_funcs(self) -> 'CoreFuncs':
        """The core functions of the sampling."""
        pass

    def as_chain(self, num_steps: int):
        """Returns the VMC sampling as an array object.

        :param num_steps: The number of states to generate.
        """
        spec_nt = self.spec_nt
        return self.core_funcs.as_chain(spec_nt.wf_spec,
                                        spec_nt.tpf_spec,
                                        num_steps,
                                        spec_nt.ini_sys_conf,
                                        spec_nt.rng_seed)

    def __iter__(self) -> Iterator[StateNT]:
        """Iterable interface."""
        spec_nt = self.spec_nt
        return self.core_funcs.generator(spec_nt.wf_spec,
                                         spec_nt.tpf_spec,
                                         spec_nt.ini_sys_conf,
                                         spec_nt.rng_seed)


# noinspection PyUnusedLocal
def _wf_abs_log_stub(sys_conf: np.ndarray, spec: WFSpecNT) -> float:
    """Stub for the probability density function (p.d.f.)."""
    pass


# noinspection PyUnusedLocal
def _ith_sys_conf_tpf_stub(i_: int, ini_sys_conf: np.ndarray,
                           prop_sys_conf: np.ndarray,
                           tpf_spec: Union[NTPFSpecNT, UTPFSpecNT]) -> float:
    """Stub for the (i-th particle) transition probability function."""
    pass


# noinspection PyUnusedLocal
def _sys_conf_tpf_stub(ini_sys_conf: np.ndarray,
                       prop_sys_conf: np.ndarray,
                       tpf_spec: Union[NTPFSpecNT, UTPFSpecNT]):
    """Stub for the transition probability function."""
    pass


@jit(nopython=True)
def rand_displace_normal(tpf_spec: NTPFSpecNT):
    """Generates a random number from a normal distribution with
    zero mean and a a standard deviation ``ppf_spec.move_spread``.
    """
    # Avoid `Untyped global name error` when executing the code in a
    # multiprocessing pool.
    # TODO: Make tests with the symbols imported globally
    normal = random.normal

    # NOTE: We may use the time-step approach.
    # Some papers suggest to use the same Gaussian proposal
    # probability function, but with a **time step** parameter,
    # which is equal to the variance of the proposal distribution.
    # sigma = sqrt(time_step)
    sigma = tpf_spec.sigma
    return normal(0, sigma)


@jit(nopython=True)
def rand_displace_uniform(tpf_spec: UTPFSpecNT):
    """Generates a random number from a uniform distribution.

    The number lies in the half-open interval
    ``[-0.5 * move_spread, 0.5 * move_spread)``, with
    ``move_spread = spec.move_spread``.

    :param tpf_spec:
    :return:
    """
    # Avoid `Untyped global name error` when executing the code in a
    # multiprocessing pool.
    rand = random.rand
    move_spread = tpf_spec.move_spread
    return (rand() - 0.5) * move_spread


class CoreFuncsMeta(ABCMeta):
    """Metaclass for :class:`CoreFuncs` abstract base class."""
    pass


class CoreFuncs(metaclass=CoreFuncsMeta):
    """The core functions to realize a VMC sampling.

    These functions perform the sampling of the probability density of a QMC
    model using the Metropolis-Hastings algorithm. A uniform distribution is
    used to generate random numbers.
    """

    @property
    @abstractmethod
    def wf_abs_log(self):
        """The probability density function (p.d.f.) to sample."""
        pass

    @cached_property
    def rand_displace(self):
        """Generates a random number from a normal distribution."""
        return rand_displace_uniform

    @property
    @abstractmethod
    def ith_sys_conf_tpf(self):
        """The transition probability function applied to the ith particle."""
        pass

    @property
    @abstractmethod
    def sys_conf_tpf(self):
        """The transition probability function."""
        pass

    @cached_property
    def generator(self):
        """VMC sampling generator.

        A generator object for the sampling configurations that follow
        the p.d.f.

        :return:
        """
        wf_abs_log = self.wf_abs_log
        sys_conf_tpf = self.sys_conf_tpf

        @jit(nopython=True, nogil=True)
        def _generator(wf_spec: WFSpecNT,
                       tpf_spec: Union[NTPFSpecNT, UTPFSpecNT],
                       ini_sys_conf: np.ndarray,
                       rng_seed: int):
            """VMC sampling generator.

            Generator-based sampling of the probability density function.
            The Metropolis-Hastings algorithm is used to generate the Markov
            chain. Each time a new configuration is tested, the generator
            yields it, as well as the status of the test: if the move was
            accepted, the status is ``STAT_ACCEPTED``, otherwise is
            ``STAT_REJECTED``.

            :param wf_spec: The parameters of the probability density function.
            :param tpf_spec: The parameters of the transition probability
                function.
            :param ini_sys_conf: The initial configuration of the particles.
            :param rng_seed: The seed used to generate the random numbers.
            """
            # Avoid `Untyped global name error` when executing the code in a
            # multiprocessing pool.
            # Short names :)
            rand = random.rand
            log = math.log

            # Feed the numba random number generator with the given seed.
            random.seed(rng_seed)

            # Buffers
            main_conf = np.zeros_like(ini_sys_conf)
            aux_conf = np.zeros_like(ini_sys_conf)

            # Initial configuration
            actual_conf, next_conf = main_conf, aux_conf
            actual_conf[:] = ini_sys_conf[:]

            # Initial value of the p.d.f.
            wf_abs_log_actual = wf_abs_log(actual_conf, wf_spec)

            # Yield initial value.
            # TODO: Remove the sum from the expression STAT_REJECTED + 0 when
            #  numba project gets this bug resolved (version 0.42 apparently).
            #  See https://github.com/numba/numba/issues/3565
            yield StateNT(actual_conf, wf_abs_log_actual, STAT_REJECTED + 0)

            # Iterate indefinitely.
            while True:

                # Just keep advancing...
                sys_conf_tpf(actual_conf, next_conf, tpf_spec)
                wf_abs_log_next = wf_abs_log(next_conf, wf_spec)
                move_stat = STAT_REJECTED

                # Metropolis condition
                if wf_abs_log_next > 0.5 * log(rand()) + wf_abs_log_actual:
                    # Accept the movement
                    # main_conf[:] = aux_conf[:]
                    actual_conf, next_conf = next_conf, actual_conf
                    wf_abs_log_actual = wf_abs_log_next
                    move_stat = STAT_ACCEPTED

                # NOTICE: Using a tuple creates a performance hit?
                yield StateNT(actual_conf, wf_abs_log_actual, move_stat)

        return _generator

    @cached_property
    def as_chain(self):
        """Returns the VMC sampling as an array object.

        JIT-compiled function to generate a Markov chain with the
        sampling of the probability density function.

        :return: The JIT compiled function that execute the Monte Carlo
            integration.
        """
        wf_abs_log_field = StateProp.WF_ABS_LOG.value
        move_stat_field = StateProp.MOVE_STAT.value
        generator = self.generator

        @jit(nopython=True, nogil=True)
        def _as_chain(wf_spec: WFSpecNT,
                      tpf_spec: Union[NTPFSpecNT, UTPFSpecNT],
                      num_steps: int,
                      ini_sys_conf: np.ndarray,
                      rng_seed: int):
            """Returns the VMC sampling as an array object.

            :param wf_spec: The parameters of the probability density function.
            :param tpf_spec: The parameters of the transition probability
                function.
            :param num_steps: The number of samples of the Markov chain.
            :param ini_sys_conf: The initial configuration of the particles.
            :param rng_seed: The seed used to generate the random numbers.
            :return: An array with the Markov chain configurations, the values
                of the p.d.f. and the acceptance rate.
            """
            # Check for invalid parameters 🤔.
            if not num_steps >= 1:
                raise ValueError('num_steps must be nonzero and positive')

            scb_shape = (num_steps,) + ini_sys_conf.shape
            states_confs = np.zeros(scb_shape, dtype=np.float64)
            states_props = np.empty(num_steps, dtype=states_props_dtype)

            wf_abs_log_set = states_props[wf_abs_log_field]
            move_stat_set = states_props[move_stat_field]
            accepted = 0

            sampling_iter = generator(wf_spec, tpf_spec, ini_sys_conf,
                                      rng_seed)
            for cj_, iter_values in enumerate(sampling_iter):
                # Metropolis-Hastings iterator.
                # TODO: Test use of next() function.
                sys_conf, wf_abs_log, move_stat = iter_values
                states_confs[cj_, :] = sys_conf[:]
                wf_abs_log_set[cj_] = wf_abs_log
                move_stat_set[cj_] = bool(move_stat)
                accepted += move_stat

                # Stop the iteration just before generating a new state 🤔.
                if cj_ + 1 >= num_steps:
                    break

            # TODO: Should we account burnout and transient moves?
            accept_rate = accepted / num_steps
            return StatesBatchNT(states_confs, states_props, accept_rate)

        return _as_chain


class NormalCoreFuncs(CoreFuncs, metaclass=ABCMeta):
    """The core functions to realize a VMC sampling.

    These functions perform the sampling of the probability density of a QMC
    model using the Metropolis-Hastings algorithm. A normal distribution is
    used to generate random numbers.
    """

    @cached_property
    def rand_displace(self):
        """Generates a random number from a uniform distribution."""
        return rand_displace_normal
