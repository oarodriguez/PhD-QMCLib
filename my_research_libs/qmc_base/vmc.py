"""
    my_research_libs.qmc_base.vmc
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Contains the basic classes and routines used to estimate the ground
    state properties of a quantum gas using the Variational Monte Carlo (VMC)
    technique.
"""

import math
from abc import ABCMeta, abstractmethod
from collections import Iterable
from enum import Enum, IntEnum
from typing import NamedTuple, Union

import numpy as np
from cached_property import cached_property
from numba import jit
from numpy import random as random

__all__ = [
    'CoreFuncs',
    'CoreFuncsMeta',
    'RandDisplaceStat',
    'SpecNT',
    'TPFSpecNT',
    'UniformCoreFuncs',
    'UTPFSpecNT',
    'WFSpecNT',
    'rand_displace_normal',
    'rand_displace_uniform'
]


class PPFType(str, Enum):
    """The type of """
    UNIFORM = 'uniform'
    GAUSSIAN = 'gaussian'


PPF_UNIFORM = PPFType.UNIFORM
PPF_GAUSSIAN = PPFType.GAUSSIAN


class RandDisplaceStat(IntEnum):
    """"""
    REJECTED = 0
    ACCEPTED = 1


STAT_REJECTED = int(RandDisplaceStat.REJECTED)
STAT_ACCEPTED = int(RandDisplaceStat.ACCEPTED)


class WFSpecNT(NamedTuple):
    """The parameters of the trial wave function.

    We declare this class to help with typing and nothing more. A concrete
    spec should be implemented for every concrete model. It is recommended
    to inherit from this class to keep a logical sequence in the code.
    """
    pass


class TPFSpecNT(NamedTuple):
    """The parameters of the transition probability function.

    The parameters correspond to a sampling done with random numbers
    generated from a normal (gaussian) distribution function.
    """
    #: The standard deviation of the normal distribution.
    sigma: float


class UTPFSpecNT(NamedTuple):
    """Parameters of the transition probability function.

    The parameters correspond to a sampling done with random numbers
    generated from a uniform distribution function.
    """
    move_spread: float


class SpecNT(NamedTuple):
    """The parameters to realize a sampling."""
    wf_spec: WFSpecNT
    tpf_spec: Union[TPFSpecNT, UTPFSpecNT]
    chain_samples: int
    ini_sys_conf: np.ndarray
    burn_in_samples: int
    rng_seed: int


class SamplingIterDataNT(NamedTuple):
    """The data yielded at every iteration of the VMC generator object."""
    sys_conf: np.ndarray
    wf_abs_log: float
    move_stat: int


class SamplingChainNT(NamedTuple):
    """The data of the Markov chain generated by the sampling."""
    sys_conf_chain: np.ndarray
    wf_abs_log_chain: np.ndarray
    accept_rate: float


class Sampling(Iterable, metaclass=ABCMeta):
    """Realizes a VMC sampling.

    Defines the parameters and methods to realize of a Variational Monte
    Carlo calculation.
    """
    __slots__ = ()

    #: The "time-step" (squared, average move spread) of the sampling.
    time_step: float

    #: The number of samples to generate after the burn-in phase.
    chain_samples: int

    #: The initial configuration of the sampling.
    ini_sys_conf: np.ndarray

    #: The number of samples to discard from the beginning of the chain.
    burn_in_samples: int

    #: The seed of the pseudo-RNG used to explore the configuration space.
    rng_seed: int

    #: The core functions of the sampling.
    core_funcs: 'CoreFuncs'

    @property
    @abstractmethod
    def wf_spec_nt(self):
        """The parameters of the trial eave function."""
        pass

    @property
    @abstractmethod
    def tpf_spec_nt(self):
        """The parameters of the transition probability function."""
        pass

    @property
    def spec_nt(self):
        """The spec of the VMC sampling functions as a named tuple."""
        return SpecNT(self.wf_spec_nt,
                      self.tpf_spec_nt,
                      self.chain_samples,
                      self.ini_sys_conf,
                      self.burn_in_samples,
                      self.rng_seed)

    def __iter__(self):
        """Iterable interface."""
        vmc_spec = self.spec_nt
        return self.core_funcs.generator(*vmc_spec)

    def as_chain(self):
        """Returns the VMC sampling as an array object."""
        sampling_spec = self.spec_nt
        return self.core_funcs.as_chain(*sampling_spec)


# noinspection PyUnusedLocal
def _wf_abs_log_stub(sys_conf: np.ndarray, spec: WFSpecNT) -> float:
    """Stub for the probability density function (p.d.f.)."""
    pass


# noinspection PyUnusedLocal
def _ith_sys_conf_tpf_stub(i_: int, ini_sys_conf: np.ndarray,
                           prop_sys_conf: np.ndarray,
                           tpf_spec: Union[TPFSpecNT, UTPFSpecNT]) -> float:
    """Stub for the (i-th particle) transition probability function."""
    pass


# noinspection PyUnusedLocal
def _sys_conf_tpf_stub(ini_sys_conf: np.ndarray,
                       prop_sys_conf: np.ndarray,
                       tpf_spec: Union[TPFSpecNT, UTPFSpecNT]):
    """Stub for the transition probability function."""
    pass


@jit(nopython=True)
def rand_displace_normal(tpf_spec: TPFSpecNT):
    """Generates a random number from a normal distribution with
    zero mean and a a standard deviation ``ppf_spec.move_spread``.
    """
    # Avoid `Untyped global name error` when executing the code in a
    # multiprocessing pool.
    # TODO: Make tests with the symbols imported globally
    normal = random.normal

    # NOTE: We may use the time-step approach.
    # Some papers suggest to use the same Gaussian proposal
    # probability function, but with a **time step** parameter,
    # which is equal to the variance of the proposal distribution.
    # sigma = sqrt(time_step)
    sigma = tpf_spec.sigma
    return normal(0, sigma)


@jit(nopython=True, cache=True)
def rand_displace_uniform(tpf_spec: UTPFSpecNT):
    """Generates a random number from a uniform distribution.

    The number lies in the half-open interval
    ``[-0.5 * move_spread, 0.5 * move_spread)``, with
    ``move_spread = spec.move_spread``.

    :param tpf_spec:
    :return:
    """
    # Avoid `Untyped global name error` when executing the code in a
    # multiprocessing pool.
    rand = random.rand
    move_spread = tpf_spec.move_spread
    return (rand() - 0.5) * move_spread


class CoreFuncsMeta(ABCMeta):
    """Metaclass for :class:`CoreFuncs` abstract base class."""
    pass


class CoreFuncs(metaclass=CoreFuncsMeta):
    """The core functions to realize a VMC sampling.

    These functions perform the sampling of the probability density of a QMC
    model using the Metropolis-Hastings algorithm. A normal distribution
    to generate random numbers.
    """

    @property
    @abstractmethod
    def wf_abs_log(self):
        """The probability density function (p.d.f.) to sample."""
        pass

    @cached_property
    def rand_displace(self):
        """Generates a random number from a normal distribution."""
        return rand_displace_normal

    @property
    @abstractmethod
    def ith_sys_conf_tpf(self):
        """The transition probability function applied to the ith particle."""
        pass

    @property
    @abstractmethod
    def sys_conf_tpf(self):
        """The transition probability function."""
        pass

    @cached_property
    def generator(self):
        """VMC sampling generator.

        A generator object for the sampling configurations that follow
        the p.d.f.

        :return:
        """
        wf_abs_log = self.wf_abs_log
        sys_conf_tpf = self.sys_conf_tpf

        @jit(nopython=True, cache=True, nogil=True)
        def _generator(wf_spec: WFSpecNT,
                       tpf_spec: Union[TPFSpecNT, UTPFSpecNT],
                       chain_samples: int,
                       ini_sys_conf: np.ndarray,
                       burn_in_samples: int,
                       rng_seed: int):
            """VMC sampling generator.

            Generator-based sampling of the probability density function.
            The Metropolis-Hastings algorithm is used to generate the Markov
            chain. Each time a new configuration is tested, the generator
            yields it, as well as the status of the test: if the move was
            accepted, the status is ``STAT_ACCEPTED``, otherwise is
            ``STAT_REJECTED``.

            :param wf_spec: The parameters of the probability density function.
            :param tpf_spec: The parameters of the transition probability
                function.
            :param chain_samples: The number of samples of the Markov chain.
            :param ini_sys_conf: The initial configuration of the particles.
            :param burn_in_samples: The number of samples to discard from the
                beginning of the sampling.
            :param rng_seed: The seed used to generate the random numbers.
            """

            # Check for invalid parameters.
            if not chain_samples >= 1:
                raise ValueError('chain_samples must be nonzero and positive')
            if not burn_in_samples >= 0:
                raise ValueError('burn_in_samples must be zero or positive')

            # Short names :)
            ncs = chain_samples
            bis = burn_in_samples

            # Avoid `Untyped global name error` when executing the code in a
            # multiprocessing pool.
            rand = random.rand
            log = math.log

            # Feed the numba random number generator with the given seed.
            random.seed(rng_seed)

            # Buffers
            main_conf = np.zeros_like(ini_sys_conf)
            aux_conf = np.zeros_like(ini_sys_conf)

            # Initial configuration
            actual_conf, next_conf = main_conf, aux_conf
            actual_conf[:] = ini_sys_conf[:]

            # Initial value of the p.d.f. and loop
            cj_ini, cj_end = 1, bis + ncs
            wf_abs_log_actual = wf_abs_log(actual_conf, wf_spec)

            if not bis:
                # Yield initial value.
                yield SamplingIterDataNT(actual_conf,
                                         wf_abs_log_actual,
                                         STAT_REJECTED)

            for cj_ in range(cj_ini, cj_end):

                # Just keep advancing...
                sys_conf_tpf(actual_conf, next_conf, tpf_spec)
                wf_abs_log_next = wf_abs_log(next_conf, wf_spec)
                move_stat = STAT_REJECTED

                # Metropolis condition
                if wf_abs_log_next > 0.5 * log(rand()) + wf_abs_log_actual:
                    # Accept the movement
                    # main_conf[:] = aux_conf[:]
                    actual_conf, next_conf = next_conf, actual_conf
                    wf_abs_log_actual = wf_abs_log_next
                    move_stat = STAT_ACCEPTED

                if cj_ < bis:
                    continue
                else:
                    # NOTICE: Using a tuple creates a performance hit?
                    yield SamplingIterDataNT(actual_conf,
                                             wf_abs_log_actual,
                                             move_stat)

        return _generator

    @cached_property
    def as_chain(self):
        """Returns the VMC sampling as an array object.

        JIT-compiled function to generate a Markov chain with the
        sampling of the probability density function.

        :return: The JIT compiled function that execute the Monte Carlo
            integration.
        """
        generator = self.generator

        @jit(nopython=True, cache=True, nogil=True)
        def _as_chain(wf_spec: WFSpecNT,
                      tpf_spec: Union[TPFSpecNT, UTPFSpecNT],
                      chain_samples: int,
                      ini_sys_conf: np.ndarray,
                      burn_in_samples: int,
                      rng_seed: int):
            """Returns the VMC sampling as an array object.

            :param wf_spec: The parameters of the probability density function.
            :param tpf_spec: The parameters of the transition probability
                function.
            :param chain_samples: The number of samples of the Markov chain.
            :param ini_sys_conf: The initial configuration of the particles.
            :param burn_in_samples: The number of samples to discard from the
                beginning of the sampling.
            :param rng_seed: The seed used to generate the random numbers.
            :return: An array with the Markov chain configurations, the values
                of the p.d.f. and the acceptance rate.
            """
            # Check for invalid parameters.
            # NOTE: The same test is done in the generator ðŸ¤”.
            if not chain_samples >= 1:
                raise ValueError('chain_samples must be nonzero and positive')
            if not burn_in_samples >= 0:
                raise ValueError('burn_in_samples must be zero or positive')

            # TODO: What is better: allocate or pass a pre-allocated buffer?
            mcs = (chain_samples,) + ini_sys_conf.shape
            sys_conf_chain = np.zeros(mcs, dtype=np.float64)
            wf_abs_log_chain = np.zeros(chain_samples, dtype=np.float64)
            accepted = 0

            sampling_iter = generator(wf_spec, tpf_spec, chain_samples,
                                      ini_sys_conf, burn_in_samples, rng_seed)
            for cj_, iter_values in enumerate(sampling_iter):
                # Metropolis-Hastings iterator.
                # TODO: Test use of next() function.
                sys_conf, pdf_log, move_stat = iter_values
                sys_conf_chain[cj_, :] = sys_conf[:]
                wf_abs_log_chain[cj_] = pdf_log
                accepted += move_stat

            # TODO: Should we account burnout and transient moves?
            accept_rate = accepted / chain_samples
            return SamplingChainNT(sys_conf_chain,
                                   wf_abs_log_chain,
                                   accept_rate)

        return _as_chain


class UniformCoreFuncs(CoreFuncs, metaclass=ABCMeta):
    """The core functions to realize a VMC sampling.

    These functions perform the sampling of the probability density of a QMC
    model using the Metropolis-Hastings algorithm. A uniform distribution is
    used to generate random numbers.
    """

    @cached_property
    def rand_displace(self):
        """Generates a random number from a uniform distribution."""
        return rand_displace_uniform
